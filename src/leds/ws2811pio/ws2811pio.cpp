#include "ws2811pio.h"

#include <cstdlib>  
#include <cstdio>
#include "etl/rounded_integral_division.h"

extern "C" {
#include "ws2811.pio.h" // header autogenerated by CMake (see pico_generate_pio_header). 
                        // To manually generate it: pioasm -o c-sdk ws2811.pio > ws2811.pio.h

#include "hardware/timer.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/irq.h"
#include "pico/stdlib.h"
#include "pico/time.h"
}

#include "../../draw.h"
#include "../../effects/effects_lib.h"

constexpr int reset_time_ns = 50'000;   /// Number of nanoseconds LOW for WS2811 RESET signal

//
// constructor
//
WS2811Pio::WS2811Pio(uint bps, uint8_t pin) {
    // ensure only one instance or die
    if (instance_ != nullptr) {
        abort();
    }
    instance_ = this;

    install_pio_and_run(pin, bps);

    setup_dma();

    // pre-calc how many words to send to get at least a RESET signal
    int ns_per_bit = (1'000'000'000 / bps); // as nanoseconds to avoid floating point
    int bits_for_reset = reset_time_ns / ns_per_bit;
    num_words_to_reset_ = etl::divide_round_to_ceiling(bits_for_reset, 32);
}


//
// install_pio_and_run
//
void WS2811Pio::install_pio_and_run(uint8_t pin, uint bps)
{
    // load PIO program into State Machine
    bool is_added = pio_claim_free_sm_and_add_program(&ws2811pio_program, &pio_, &sm_, &offset_);
    if (!is_added)
    {
        assert("Failed to load pio program");
        std::abort();
    }

    ws2811pio_program_init(pio_, sm_, offset_, pin, bps, false);
}


//
// Set up DMA channel to PIO State Machine once State Machine has been allocated. 
//
void WS2811Pio::setup_dma() {
    // configure a DMA channel:
    //   the PIO State Machine will issue a DREQ when ready
    //   transfer 32-bits at a time
    //   increment memory read addresses after each transfer
    //   write to the same address (the TX FIFO)
    dma_chan_ = (uint)dma_claim_unused_channel(true); // if arg = false, dma_chan_ could be -1
    dma_channel_config_t cfg = dma_channel_get_default_config(dma_chan_);
    channel_config_set_dreq(&cfg, pio_get_dreq(pio_, sm_, true)); 
    channel_config_set_transfer_data_size(&cfg, DMA_SIZE_32);  
    channel_config_set_read_increment(&cfg, true);
    channel_config_set_write_increment(&cfg, false);

    dma_channel_configure(dma_chan_,
                        &cfg,
                        &pio_->txf[sm_],// write address: write to PIO FIFO
                        NULL,           // don't provide a read address yet 
                        1,              // fake number of transfers (provided in `send`)
                        false);         // don't start yet
    

    // register and IRQ handler that is fired at the end of each DMA transfer so we can
    // send a RESET signal to the LEDs.
    irq_set_exclusive_handler(DMA_IRQ_0, dma_irq_handler_c_wrapper); 
    dma_channel_set_irq0_enabled(dma_chan_, true);
    irq_set_enabled(DMA_IRQ_0, true);
}


//
// destructor
//
WS2811Pio::~WS2811Pio() {
    pio_remove_program_and_unclaim_sm(&ws2811pio_program, pio_, sm_, offset_);
    
    dma_channel_cleanup(dma_chan_);
    dma_channel_unclaim(dma_chan_);
}


// C Wrapper for IRQ handler for DMA transfers. This is static so allows us to register IRQ 
// handler with Pico SDK
void WS2811Pio::dma_irq_handler_c_wrapper(void) {
    instance_->dma_irq_handler(); // need member variables so pass to instance
}


// IRQ handler for DMA transfers called from the static function `dma_irq_handler_c_wrapper`. This
// allows us to use member variables in our IRQ handler.
void WS2811Pio::dma_irq_handler() {
    if (dma_channel_get_irq0_status(dma_chan_)) {
        dma_channel_acknowledge_irq0(dma_chan_); // clear IRQ flag
        send_reset_signal();  
    }
}


// Send RESET signal to LEDs to latch data in WS2811 chips and hence display the new frame
//
//
void WS2811Pio::send_reset_signal() {
    // TODO: to avoid taking up 50us if this is called from an IRQ handler, we send only 1 32-bit low signal
    // to the TX FIFO, setting up an alarm to allow further writes.
    for (int i = 0; i < num_words_to_reset_; i++) {
        pio_sm_put_blocking(pio_, sm_, 0);
    }
}


//
// Initiate DMA transfer from frame.data to PIO state machines TX FIFO
//
void WS2811Pio::send(const Frame& frame) {
    // block until current DMA xfer complete (if any)
    dma_channel_wait_for_finish_blocking(dma_chan_);
    printf("DMA chan ready");
    // how many words (32bit) to transfer over DMA
    dma_channel_set_transfer_count(dma_chan_, dma_encode_transfer_count(frame.num_leds), false);
    //printf("DMA transfer count %u", dma_encode_transfer_count(frame.num_leds));

    // DMA reads from frame and go!
    bool start_now = true;
    dma_channel_set_read_addr(dma_chan_, &frame.data[0], start_now); 
    
};


/**
 * @brief Test LEDs work without using DMA transfer
 * 
 * This blocks forever.
 */
void WS2811Pio::test(size_t num_leds) {
   
    Frame frame(num_leds);
    etl::array<unsigned short, 1> fft_mags {1};
    DrawInfo<unsigned short, 1> info {(unsigned short)0, fft_mags};
    LaserEffect effect;

    uint64_t now_us;
    uint64_t last_called_time_us = time_us_64();
    while (true) {
   // calling pio_sm_put_blocking sequentially/in a loop will work as long as the TX FIFO
   // is filled within the RESET time of the WS2811 (typically ~50us). Given a 125MHz clock
   // that gives ~6250 cycles to fill the FIFO before the WS2811 latches and stops accepting data
        
        // for (uint i = 0; i < num_leds; i++) {
        //     pio_sm_put_blocking(pio_, sm_, RED.as_RGB());  
        // }
        // busy_wait_ms(2000);

        // for (uint i = 0; i < num_leds; i++) {
        //     pio_sm_put_blocking(pio_, sm_, BLUE.as_RGB());  // write word to TX FIFO
        // }
        // busy_wait_ms(2000);

        
        // for (uint i = 0; i < num_leds; i++) {
        //     pio_sm_put_blocking(pio_, sm_, LIME.as_RGB());  
        // }
        // busy_wait_ms(2000);

        // calc elapsed time since last call to draw frame
        now_us = time_us_64();
        info.elapsed_time_us = now_us - last_called_time_us;
        last_called_time_us = now_us;
        
        effect.draw_frame(frame, info);

        for (uint i = 0; i < frame.num_leds; i++) {
              pio_sm_put_blocking(pio_, sm_, frame.data[i].as_RGB());  
        }
        
        #ifndef NDEBUG
            //less than 800us LEDs don't latch at 400kBs during debugging
            //less than 500us LEDs don't latch at 800kBs during debugging
            busy_wait_us(800); 
        #else
            busy_wait_us(50); 
        #endif
        
    }
    
}


