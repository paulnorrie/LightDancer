#include "ws2811pio.h"

#include <cstdlib>  
#include <cstdio>

extern "C" {
#include "ws2811.pio.h" // header autogenerated by CMake (see pico_generate_pio_header). 
                        // To manually generate it: pioasm -o c-sdk ws2811.pio > ws2811.pio.h

#include "hardware/timer.h"
#include "hardware/pio.h"
#include "pico/stdlib.h"
}



WS2811Pio::WS2811Pio(uint bps, uint8_t pin) {
    bool is_added = pio_claim_free_sm_and_add_program(&ws2811pio_program, &pio_, &sm_, &offset_);
    if (!is_added) { 
        assert("Failed to load pio program");
        std::abort(); 
    }
    
    ws2811pio_program_init(pio_, sm_, offset_ , pin, bps, false); 
    
}


WS2811Pio::~WS2811Pio() {
    pio_remove_program_and_unclaim_sm(&ws2811pio_program, pio_, sm_, offset_);
}


void WS2811Pio::send(const Frame& frame) {
    // TODO: 
    // 1. block until current DMA xfer complete (if any)
    // 2. initiate DMA transfer from frame data to PIO TX FIFO
    // 3. return
    // 4. block_delay_us(50);  // latch delay on DMA Transfer complete interrupt
};


/**
 * @brief Test LEDs work with blinking pattern of Red, Green, & Blue colours every 2s.
 * 
 * This blocks forever.
 */
void WS2811Pio::test(size_t num_leds) {
        
   // calling pio_sm_put_blocking sequentially/in a loop will work as long as the TX FIFO
   // is filled within the RESET time of the WS2811 (typically ~50us). Given a 125MHz clock
   // that gives ~6250 cycles to fill the FIFO before the WS2811 latches and stops accepting data
    while (true) {
        for (uint i = 0; i < num_leds; i++) {
            pio_sm_put_blocking(pio_, sm_, WHITE.as_RGB());  // write word to TX FIFO
        }
        busy_wait_ms(2000);

        for (uint i = 0; i < num_leds; i++) {
            pio_sm_put_blocking(pio_, sm_, RED.as_RGB());  
        }
        busy_wait_ms(2000);

        for (uint i = 0; i < num_leds; i++) {
            pio_sm_put_blocking(pio_, sm_, LIME.as_RGB());  
        }
        busy_wait_ms(2000);

        for (uint i = 0; i < num_leds; i++) {
            pio_sm_put_blocking(pio_, sm_, BLUE.as_RGB());  
        }
        busy_wait_ms(2000);
    }
    
    
}


