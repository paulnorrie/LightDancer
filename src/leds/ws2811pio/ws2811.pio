; Programmable I/O assembly code for driving WS2811 LEDs
; 

.program ws2811pio

.side_set 1 opt ; use 1 of the 5 bit delay bits for side-set to control 1 pin

; WS2811 operates at 400KHz (when VDD connected with SET pin) or 800KHz otherwise.
; Timing is not standard and datasheets vary but typically (confirm with your datasheet):
; | Freq    | 0 bit           | 1 bit           | Tolerance | Time per bit | 
; |         | High   | Low    | High   | Low    |           |              |
; |---------|--------|--------|--------|--------|-----------|--------------|
; | 400KHz  | 500ns  | 2000ns | 1200ns | 1300ns | +/-150ns  | 2500ns       |
; | 800KHz  | 250ns  | 1000ns | 1000ns | 250ns  | +/-80ns   | 1250ns       |
; A RESET/LATCH signal at the end of the data is generally 50,000ns but some can be up to 280,000ns.
; Most internet commentary suggests WS2811 devices are quite forgiving of timing issues.
;
; Timing diagram
; --------------
; Low (0) bit: 
; Clock: |     |     |     |     |     |     |     |     |     |     |     |
;         _____/‾‾‾‾‾‾‾‾‾‾‾\________________________________________________
;              |--- T0H ---|--------------------- T0L ---------------------|
;
; High (1) bit: 
; Clock: |     |     |     |     |     |     |     |     |     |     |     |
;         _____/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\________________________
;              |------------ T1H ------------------|---------- T1L --------|
;
;              |--- Ta ---|----------- Tb ---------|---------- Tc ---------|
; Where:
; T0H = number of cycles high for 0 bit
; T0L = number of cycles low for 0 bit
; T1H = number of cycles high for 1 bit
; T0L = number of cycles low for 1 bit
;
; After data transmission, the LEDs have not changed colour, the data is only in a register in the
; WS2811. To signal the LEDs to use this data a RESET signal must be sent.
; This is either 50us (@400KHz) or 25us (@800KHz), or for old WS2811 280us.
;
; Default cycles for the timing in table above at 800KHz with ticks every 125ns/10 ticks per bit
; You can change these defaults in C by #define ws2811pio_T0H, etc.
.define PUBLIC T0H 1    ; number of cycles to hold high for a '0' bit
.define PUBLIC T0L 4    ; number of cycles to hold low for a '0' bit
.define PUBLIC T1H 4    ; number of cycles to hold high for a '1' bit
.define PUBLIC T1L 1    ; number of cycles to hold low for a '1' bit

  pull      side 0      ; TX FIFO -> OSR, stall until data available and always go low

.wrap_target
next_bit:
 ; always entering this loop on a low so that a TX stall keeps the output low
 out x, 1       side 1  [T0H - 1]       ; next bit OSR -> x reg, start both 0 and 1 high for Ta cycles
 mov pins, x            [T1H - T0H - 1] ; output to 0 or 1 for Tb cycles
 pull ifempty   side 0  [T1L - 1]       ; end on 0 for Tc cycles, 
                                        ; get next 32-bit word into OSR if we 
                                        ; have emptied OSR 
                                        ; stall if no more words in TX FIFO (may trigger a RESET after 50us)
.wrap 

; 
% c-sdk {
#include "hardware/clocks.h"

/**
 * Initialise this PIO program with C.  Enables driving one pin (LED strip) only.
*/
static inline void ws2811pio_program_init(
    PIO pio,        // PIO bank  
    uint sm,        // State Machine number (0-4)
    uint offset, 
    uint pin,       // Pin # (0-31)
    uint bps,
    bool rgbw) {

    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true); // SET instruction drives output `pin`
    
    // configure state-machine
    pio_sm_config c = ws2811pio_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, pin);    // side-set writes to `pin`
    sm_config_set_out_pins(&c, pin, 1);     // OUT+MOV instructions drives output on given pin
    sm_config_set_out_shift(&c, false, true, rgbw ? 32 : 24); // shift-left (MSB -> OSR first), autopull 
    //sm_config_set_out_shift(&c, false, true, 32); // shift-left (MSB -> OSR first), autopull when empty OSR
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX); // use RX FIFO to increase TX FIFO size

    // PIO clock operates every subset of system clock to transmit at chosen bps
    int cycles_per_bit = ws2811pio_T0H + ws2811pio_T1H; 
    float div = clock_get_hz(clk_sys) / (bps * cycles_per_bit);
    sm_config_set_clkdiv(&c, div);

    // Load config and start
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
    }

%}